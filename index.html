<!doctype html>
<html>
  <head>
    <style>#content {
  width: 900px;
  margin: auto;
}
</style>
  </head>
  <body>
    <div id=content>
    <h1 id="performance-of-various-javascript-crypto-implementations">performance of various javascript crypto implementations</h1>
<p>Dominic Tarr (Stackvm) 2014-01-26</p>
<h2 id="abstract">Abstract</h2>
<p>Javascript is already used for nearly everything, so it&#39;s inivitable that it must be used for cryptography also.
There are a few javascript crypto implementations available, which are of varying quality, as the following will demonstrate.</p>
<h2 id="method">Method</h2>
<p>So far, I have benchmarks for measuring hashing performance against input size,
and key deriviation performance (pbkdf2) as the number of iterations are increased.
hashing a &quot;large&quot; file measures throughput, while key deriviation depends on creating many hashes
repeatedly - whether many hashes can be created in succession is quite a different measurement.</p>
<p>since javascript timers are not very precise, if the time taking to hash is under 100 ms,
the hash is repeated until the elasped time is &gt; 100ms, and the the time taken is adjusted
to <code>time_taken/repeated_runs</code>.</p>
<h2 id="crypto-implementations">crypto implementations</h2>
<ul>
<li>stanford javascript crypto library (sjcl)</li>
<li>crypto-js</li>
<li>forge</li>
<li>crypto-browserify</li>
</ul>
<h2 id="hashing-a-0-10mb-file">hashing a 0-10MB file</h2>
<p>Since each library provides a different api, each api has been wrapped to a function
that takes a buffer, and then converts to a format that the algorithm can process,
and calls the hash function with one buffer.</p>
<p>This is not necessarily fair on each library, but it would be surprising if
encoding had more than a small effect on hashing performance.</p>
<h3 id="sha1-time-taken-against-input-size-">SHA1, time taken against input size.</h3>
<p><img src="./graphs/hash-sha1.png" alt="sha1 hashing a 0-10MB file"></p>
<blockquote>
<p>(y-axis shows total time taken, higher is better)</p>
</blockquote>
<p>every implementation behaves basically linearly with input size,
excep that crypto-browserify becomes more efficient once inputsize becomes about 2mb.
Below 2mb, forge is slightly ahead of crypto-browserify, and sjcl and crypto-js are
significantly slower as file size increases.</p>
<h3 id="sha1-bytes-hashed-per-millisecond">SHA1, bytes hashed per millisecond</h3>
<p><img src="./graphs/hash-ops-sha1.png" alt="sha1 hashing a 0-10MB file"></p>
<blockquote>
<p>(y-axis shows time/input size, lower is better)</p>
</blockquote>
<p>When comparing the rate of hashing against input size, the improvement in crypto-browserify&#39;s
performance becomes readdily apparent. My suspucion is that the over head of allocating
TypedArrays is what slows down crypto-browserify at low input size.
A future experiment will be to manage TypedArrays with pooling or some such,
to make repeated hashes faster.</p>
<h3 id="sha256-time-taken-against-input-size-">SHA256, time taken against input size.</h3>
<p><img src="./graphs/hash-sha256.png" alt="sha256 hashing a 0-10MB file"></p>
<blockquote>
<p>(y-axis shows total time taken, higher is better)</p>
</blockquote>
<p>sjcl and crypto-js performance at sha256 seems much the same as for sha1,
but forge is faster than cryto-browserify, which doesn&#39;t show any improvement with input size.</p>
<h3 id="sha256-time-taken-against-input-size-">SHA256, time taken against input size.</h3>
<p><img src="./graphs/hash-ops-sha256.png" alt="sha256 hashing a 0-10MB file"></p>
<blockquote>
<p>(y-axis shows time/input size, lower is better)</p>
</blockquote>
<p>forge is clearly faster, and crypto-browserify does not show any improvement.
also note that the performance of both forge and crypto-browserify is over 20k bytes per ms,
about the performance of crypto-browserify&#39;s sha1.</p>
<h2 id="key-derivation-pbkdf2-">key derivation (pbkdf2)</h2>
<h3 id="pbkdf2-sha1-time-taken-against-iterations-">pbkdf2(sha1), time taken against iterations.</h3>
<p><img src="./graphs/hash-sha1.png" alt="pbkdf2(sha1) 1 - 10k iterations"></p>
<blockquote>
<p>(y-axis shows total time taken, higher is better)</p>
</blockquote>
<p>This graph shows that crypto-js&#39;s pbkdf2 has non-linear performance.
something is clearly wrong, as there is no reason this should not be linear.
compared to crypto-js, the other libraries are not even on this scale.</p>
<h3 id="sha1-pbkdf-iterations-per-millisecond-">sha1 pbkdf, iterations per millisecond.</h3>
<p><img src="./graphs/hash-ops-sha1.png" alt="pbkdf2(sha1) 1 - 10k iterations"></p>
<blockquote>
<p>(y-axis shows time/input size, lower is better)</p>
</blockquote>
<p>looking at the iterations per ms, we see that sjcl, which was the slowest on large files,
is the fastest with rapid iterations. This suggests that there is something about the
crypto-browserify and forge implementations which make the hash objects heavy to create,
but efficient once created. If this is correct, they could possibly be improved with pooling.</p>
<h3 id="pbkdf2-sha256-time-taken-against-iterations-">pbkdf2(sha256), time taken against iterations.</h3>
<p><img src="./graph/hash-sha256.png" alt="pbkdf2(sha256) 1 - 10k iterations"></p>
<blockquote>
<p>(y-axis shows total time taken, higher is better)</p>
</blockquote>
<p>Again, crytpo-js has non-linear scaling.</p>
<h3 id="sha256-pbkdf-iterations-per-millisecond-">sha256 pbkdf, iterations per millisecond.</h3>
<p><img src="./graph/hash-ops-sha256.png" alt="pbkdf2(sha256) 1 - 10k iterations"></p>
<blockquote>
<p>(y-axis shows time/input size, lower is better)</p>
</blockquote>
<p>interestingly, the relative performance of sjcl is even more impressive,
about 4 times greater than sha1 (it&#39;s not surprising that sha256 is the default
hash algorithim for sjcl)</p>
<h2 id="conclusion">conclusion</h2>
<p>the hash algorithms in sjcl, crypto-browserify, and forge, have been optimized for different purposes.
It appears that crypto-js hasn&#39;t been optimized, after the correctness of the implementation has been verified.</p>


    </div>
  </body>
</html>
